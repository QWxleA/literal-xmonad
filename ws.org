#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline author:t
#+options: broken-links:nil c:nil creator:nil d:(not "LOGBOOK") date:t e:t email:nil
#+options: f:t inline:t num:nil p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:1 todo:t |:t
#+OPTIONS: html-style:nil :html-head-include-scripts nil
#+title: Literal XMonad
#+date: <2020-12-24 Thu>
#+PROPERTY: header-args  :mkdirp yes
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="res/org.css"/>
#+EXPORT_FILE_NAME: index.html

**Note:** The source of this document does not always look nice, but otherwise my haskell sources wouldn't line up correctly

Use Emacs to export this configuration, but be carefull as it might also overwrite other settings!

* Build Xmonad

  Install dependencies:

  #+begin_example shell
  sudo pacman -S stack
  #+end_example

  - stack init  :  Create stack project config from cabal or hpack package specifications
  - stack build :  Build the package(s) in this directory/configuration
  - stack install: Shortcut for 'build --copy-bins'

  #+CAPTION: Xmonad build script
  #+begin_src sh :tangle-mode (identity #o555) :tangle "~/.config/xmonad/build" :mkdirp yes
    #!/bin/sh
    #
    # As of 0.13, xmonad --recompile will look for a custom build script.
    # Keep & after notify-send, if dunst is not running the process will hang
    #set -e

    EXEC_PATH="$1"
    ICON="~/Pictures/Icons/Xmonad-logo.svg.png"
    echo "DB: EXEC_PATH: $EXEC_PATH"

    die() {
        notify-send "Xmonad build FAILED!" "$1" -i "$ICON" &
        echo "Xmonad build FAILED! $1"
        exit 1
        }

    cd ~/.config/xmonad
    notify-send "Xmonad" "Build started ($1)" -i "$ICON" &
    #stack build || stack init
    stack install || die "Build error ($@)"
    ln -sf ~/.local/bin/xmonad $EXEC_PATH #!!
    xmonad --restart && notify-send "Xmonad build SUCCES!" "Restarted at $(date)" -i "$ICON" &
  #+end_src

  *Note:* Fitspec is needed for the cheatsheet.

  #+begin_src yaml1 :tangle "~/.config/xmonad/package.yaml" :noweb tangle
    name: myXmonad
    version: 0.0.7

    dependencies:
        - base
        - xmonad
        - xmonad-contrib
        - split
        - fitspec

    library:
        source-dirs: src

    executables:
        xmonad:
            source-dirs:  app
            main:         Main.hs
            dependencies: myXmonad
            ghc-options:
                - -threaded
                - -rtsopts
                - -with-rtsopts=-N
                - -Wall
  #+end_src

* app/Main.hs
  :PROPERTIES:
  :header-args:  :tangle "~/.config/xmonad/app/Main.hs"
  :END:

** Header

   #+begin_src haskell
     ---------------------------------------------------------------------------
     --                                                                       --
     --     _|      _|  _|      _|                                      _|    --
     --       _|  _|    _|_|  _|_|    _|_|    _|_|_|      _|_|_|    _|_|_|    --
     --         _|      _|  _|  _|  _|    _|  _|    _|  _|    _|  _|    _|    --
     --       _|  _|    _|      _|  _|    _|  _|    _|  _|    _|  _|    _|    --
     --     _|      _|  _|      _|    _|_|    _|    _|    _|_|_|    _|_|_|    --
     --                                                                       --
     ---------------------------------------------------------------------------
     -- Alex <qwxlea@gmail.com>                                               --
     -- https://github.com/qwxlea                                             --
     ---------------------------------------------------------------------------
     -- current as of XMonad 0.15
     ---------------------------------------------------------------------------
     module Main where
   #+end_src

** Body

  *Modules needed:*

   #+begin_src haskell -n
     import XMonad                                   -- standard xmonad library
     import XMonad.Config.Desktop                    -- default desktopConfig
     import XMonad.Hooks.EwmhDesktops                -- Fixes the automatic fullscreening & wmctrl
     import XMonad.Util.NamedActions (addDescrKeys') -- Don't use default key bindings
     import XMonad.Util.SpawnOnce (spawnOnce)        -- For running autostart only once (on login)

     import XMonad.Actions.DynamicProjects           -- For WS.projects
     import XMonad.Util.Run(spawnPipe)               -- For xmobar src/MyBar

     import Options                                  -- All stored under /src/
     import MyKeys
     import MyCheatsheet
     import MyBar
     import MyLayoutHook
     import MyManageHook
     import MyWorkspaces as WS

   #+end_src

   main function, high ho, silver!:

   #+begin_src haskell +n
     main :: IO ()
     main = do
         xmproc <- spawnPipe "xmobar ~/.config/xmobar/xmobarrc.hs"
         -- xmproc <- spawnPipe "xmobar ~/.config/xmobar/xmobarDebug.hs"

         xmonad                                                        -- applied over defaults
             $ dynamicProjects WS.projects                             -- See MyWorkspaces
             $ addDescrKeys' (myCheatsheetKey, myCheatsheet) myKeys    -- See myCheatsheet
             $ ewmh desktopConfig                                      -- xdotool and wmtrl are great!
               { modMask            = myModMask
               , terminal           = myTerminal
               , borderWidth        = myBorderWidth
               , normalBorderColor  = myNormalBorderColor
               , focusedBorderColor = myFocusedBorderColor
               , manageHook         = myManageHook
               , layoutHook         = myLayoutHook
               , logHook            = myLogHook xmproc
               , workspaces         = WS.names
               , startupHook        = spawnOnce myAutostart
               }

   #+end_src

* src/Options.hs
  :PROPERTIES:
  :header-args: :tangle "~/.config/xmonad/src/Options.hs"
  :END:

  The idea is to set up all the defaults here, instead all over the place. So far my success has been limited.

  *Modules needed:*

  #+begin_src haskell
    module Options where

    import XMonad
    import qualified XMonad.Actions.Search as S

    -- The modifier key to be used for most keybindings
    -- I have it set to super (the Windows key)
    myModMask :: KeyMask
    myModMask  = mod4Mask
  #+end_src

  Default applications, scripts end with a capital /S/, like =screenshotS=.

  #+begin_src haskell -n
    ---------------------------------------------------------------------------
    -- Applications                                                         ---
    ---------------------------------------------------------------------------

    myTerminal       = "alacritty"
    myEditor         = "emacsclient -c"
    myBrowser        = "qutebrowser"
    myFileManager    = myTerminal ++ " -e ranger "
    myGuiFileManager = "pcmanfm"
    myPdfReader      = "zathura"
    myPrintScreen    = "screenshotS"
    myAudiocontrol   = "pavucontrol"

    data Bar = Taffybar | XMobar | Tint2 deriving (Eq)
    myBar :: Bar
    myBar = XMobar

    myMenu :: String
    myMenu = "rofi -dmenu -i -p"  -- For scripts that require user input

    myAppM :: String
    myAppM = "rofi -show drun"    -- Start software

  #+end_src

  Default file paths.

  #+begin_src haskell -n
    ---------------------------------------------------------------------------
    -- File Paths                                                           ---
    ---------------------------------------------------------------------------

    myConfigDir       = "~/.config/xmonad/src/"       -- XMonad-related config
    myBuildScript     = "~/.config/xmonad/build"      -- Script to recompile and restart xmonad
    myAutostart       = "~/.config/xmonad/src/autostartS" -- Script to run on login
    myXMobarConf      = "~/.config/xmobar/xmobarrc.hs"
    myStalonetrayConf = "~/.config/stalonetray/stalonetrayrc"
    myTint2Conf       = "~/.config/tint2/xmonad.tint2rc"

  #+end_src

  Theme; colors, fonts etc

  #+begin_src haskell
    ---------------------------------------------------------------------------
    -- Theme                                                               ---
    ---------------------------------------------------------------------------

    rofiTheme theme = "~/.config/rofi/themes/" ++ theme ++ ".rasi" -- Rofi theme directory

    myBorderWidth :: Dimension
    myBorderWidth = 2

    -- Tab colours copied from DistroTube's config (at gitlab/dwt1)
    myTabActiveColor      = "#46D9FF"
    myTabInactiveColor       = "#313846"
    myTabActiveBorderColor   = "#46D9FF"
    myTabInactiveBorderColor = "#282C34"
    myTabActiveTextColor     = "#282C34"
    myTabInactiveTextColor   = "#D0D0D0"

    myFocusFollowsMouse  = False
    myClickJustFocuses   = True

    base03  = "#002b36"
    base02  = "#073642"
    base01  = "#586e75"
    base00  = "#657b83"
    base0   = "#839496"
    base1   = "#93a1a1"
    base2   = "#eee8d5"
    base3   = "#fdf6e3"
    yellow  = "#b58900"
    orange  = "#cb4b16"
    red     = "#dc322f"
    magenta = "#d33682"
    violet  = "#6c71c4"
    blue    = "#268bd2"
    cyan    = "#2aa198"
    green   = "#859900"

    -- sizes
    gap         = 10
    topbar      = 10
    myBorder    =  2
    prompt :: Dimension
    prompt      = 30
    status      = 20

    myNormalBorderColor, myFocusedBorderColor :: String
    myNormalBorderColor     = "#000000"
    myFocusedBorderColor    = active

    active       = blue
    activeWarn   = red
    inactive     = violet
    focusColor   = blue
    unfocusColor = base02

    myFont       = "xft:NotoSansMono Nerd Font:style=Regular:size=12:antialias=true:hinting=true"
    myMediumFont = "xft:NotoSansMono Nerd Font:style=Regular:size=32:antialias=true:hinting=true"
    myLargeFont  = "xft:NotoSansMono Nerd Font:style=Bold:size=60:antialias=true:hinting=true"


  #+end_src

  Search engines, several from [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-Search.html][XMonad.Actions.Search]] + custom ones I regularly use:

  #+begin_src haskell -n
    archwiki, news, reddit, urban :: S.SearchEngine

    archwiki = S.searchEngine "archwiki" "https://wiki.archlinux.org/index.php?search="
    news     = S.searchEngine "news" "https://news.google.com/search?q="
    reddit   = S.searchEngine "reddit" "https://www.reddit.com/search/?q="
    urban    = S.searchEngine "urban" "https://www.urbandictionary.com/define.php?term="

    searchList :: [(String, S.SearchEngine)]
    searchList = [ ("g", S.google)
                 , ("h", S.hoogle)
                 , ("w", S.wikipedia)
                 , ("i", S.imdb)
                 , ("a", archwiki)
                 , ("n", news)
                 , ("r", reddit)
                 , ("u", urban)
                 , ("c", S.hackage)
                 ]
  #+end_src

* src/MyKeys.hs
  :PROPERTIES:
  :header-args: :tangle "~/.config/xmonad/src/MyKeys.hs"
  :END:

  Interesting part:

  - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-NamedActions.html][XMonad.Util.NamedActions]] -- Which is used by the [[*src/MyCheatsheet][cheatsheet]].

  *Modules needed:*

  #+CAPTION: MyKeys definition
  #+begin_src haskell -n
    module MyKeys
    (myKeys,myCheatsheetKey)
    where

    import Data.Char (isSpace, toUpper) --isSpace?
    import System.Exit -- (exitSuccess)
    import XMonad

    import XMonad.Layout.MultiToggle
    import XMonad.Layout.MultiToggle.Instances
    import XMonad.Layout.ResizableTile
    import qualified XMonad.StackSet as W
    import XMonad.Actions.CycleWS

    import XMonad.Util.EZConfig
    import XMonad.Util.NamedActions
    import XMonad.Actions.ShowText              -- (ref:showTextM)
    import XMonad.Util.NamedScratchpad

    import XMonad.Prompt
    import XMonad.Prompt.ConfirmPrompt          -- don't just hard quit
    import XMonad.Prompt.FuzzyMatch             -- (ref:fuzzyM) TODO
    import XMonad.Prompt.Man
    import qualified XMonad.Actions.Search as S

    import XMonad.Actions.DynamicProjects       -- to switch to projects

    import XMonad.Actions.SinkAll               -- make all windows unfloat

    import Options                              -- defaults
    import MyScratchpads

  #+end_src

  #+CAPTION: Help functions
  #+begin_src haskell -n
    -- Convert multiword strings to arguments (concatenate with delimiters)
    -- This makes sure my shell scripts correctly interpret their arguments
    args :: String -> [String] -> String
    args command arguments = command ++ " " ++ unwords (map show arguments)

    quitXmonad :: X ()
    quitXmonad = confirmPrompt hotPromptTheme "exit"
      $ io (exitWith ExitSuccess)

    rebuildXmonad :: X ()
    rebuildXmonad = do
      -- spawn "xmonad --recompile && xmonad --restart"
      spawn myBuildScript

    restartXmonad :: X ()
    restartXmonad = do
      spawn "xmonad --restart"

  #+end_src

  Modifiers:

  - M = M1 is Super, which I have also set to space when held down TODO
  - H is Hyper, which I have set to the menu key
  - C-Esc is Super tapped on its own

  =myKeys= contains all the key bindings, also, we pre-define longer commands:

  #+CAPTION: myKeys configuration
  #+begin_src haskell -n
    myKeys :: XConfig l -> [((KeyMask, KeySym), NamedAction)]
    myKeys conf = let

        subKeys name list = subtitle name : mkNamedKeymap conf list

        -- Abbreviations for certain actions
        menuEditScript         = spawn $ args "menuEditConfigsS" [myMenu,myEditor]
        menuEditConfig         = spawn $ args "menuEditConfigsS" [myMenu,myEditor]

        viewScreen s          = screenWorkspace s >>= flip whenJust (windows . W.view)
        shiftScreen s         = screenWorkspace s >>= flip whenJust (windows . W.shift)
        unFloat               = withFocused $ windows . W.sink

        volumeAdjust "toggle" = spawn "adjustVolumeS toggle"
        volumeAdjust value    = spawn $ args "adjustVolumeS" $ words value

        in

  #+end_src

  #+CAPTION: Core Xmonad bindings
  #+begin_src haskell -n
        subKeys "Core"
        [ ("M-S-q",                   addName "Quit XMonad (logout)"   $ quitXmonad)
        , ("M-q",                     addName "Recompile & restart"    $ rebuildXmonad)
        , ("M-M1-q",                  addName "Restart"                $ restartXmonad)
        , ("C-<Escape>",              addName "Application launcher"   $ spawn myAppM)
        , ("M-S-c",                   addName "Close window"           $ kill)
        ] ^++^

  #+end_src

  Window manager bindings, for these I use =Super=:

  - Screens
  - Workspaces ([[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-CycleWS.html][XMonad.Actions.CycleWS]])
  - Layouts
  - Windows

  #+CAPTION: Layouts and Windows
  #+begin_src haskell -n
        subKeys "Layouts"
        [ ("M-h",                     addName "Shrink master"          $ sendMessage Shrink)
        , ("M-l",                     addName "Expand master"          $ sendMessage Expand)
        , ("M-i",                     addName "Shrink slave"           $ sendMessage MirrorExpand)
        , ("M-u",                     addName "Expand slave"           $ sendMessage MirrorShrink)
        , ("M-,",                     addName "Inc master windows"     $ sendMessage $ IncMasterN 1)
        , ("M-.",                     addName "Dec master windows"     $ sendMessage $ IncMasterN (-1))
        , ("M-<Space>",               addName "Next layout"            $ sendMessage NextLayout)
        , ("M-f",                     addName "Toggle fullscreen"      $ sendMessage $ Toggle NBFULL)
        ] ^++^

        subKeys "Windows"
        [ ("M-<Tab>",                 addName "Focus next"             $ windows W.focusDown)
        , ("M-S-<Tab>",               addName "Focus previous"         $ windows W.focusUp)
        , ("M-j",                     addName "Focus next"             $ windows W.focusDown)
        , ("M-k",                     addName "Focus previous"         $ windows W.focusUp)
        , ("M-m",                     addName "Focus master"           $ windows W.focusMaster)
        , ("M-S-j",                   addName "Swap next"              $ windows W.swapDown)
        , ("M-S-k",                   addName "Swap previous"          $ windows W.swapUp)
        , ("M-<Return>",              addName "Swap master"            $ windows W.swapMaster)
        , ("M-t",                     addName "Unfloat"                $ unFloat)
        , ("M-S-t",                   addName "Unfloat All"            $ sinkAll)
        ] ^++^

  #+end_src

  #+CAPTION: Projects
  #+NAME: Project keys
  #+begin_src haskell -n
        subKeys "Projects"
        [ ("M-w"   , addName "switch Project Prompt"   $ switchProjectPrompt warmPromptTheme)
        , ("M-S-w" , addName "shift To Project Prompt" $ shiftToProjectPrompt warmPromptTheme)
        ] ^++^

  #+end_src

  Application bindings, these are (mostly) using the =Hyper key= (menu):

  Note: =M-S-<Return>= is a fallback, I broke my /menu/ binding a couple of times.

  #+begin_src haskell -n
        subKeys "Applications"
        [ ("M-S-<Return>",            addName "Terminal emulator"      $ spawn myTerminal)
        , ("M3-<Return>",             addName "Terminal emulator"      $ spawn myTerminal)
        , ("M3-d",                    addName "Start apps (I3 dmenu)"  $ spawn myAppM)
        , ("M3-e",                    addName "Text editor"            $ spawn myEditor)
        , ("M3-w",                    addName "Web browser (minimal)"  $ spawn myBrowser)
        , ("M3-S-w",                  addName "Chromium"               $ spawn "chromium")
        , ("M3-C-w",                  addName "Chromium anonymous"     $ spawn "chromium --name=ignognito --incognito")
        , ("M3-f",                    addName "Terminal file manager"  $ spawn myFileManager)
        , ("M3-S-f",                  addName "Graphical file manager" $ spawn myGuiFileManager)
        , ("M3-z",                    addName "Zoom"                   $ spawn "zoom")
        ] ^++^

        subKeys "My (rofi) Scripts"
        [ ("M3-p M3-p",                 addName "Edit scripts"        $ menuEditScript)
        , ("M3-p M3-e",                 addName "Edit configs"        $ menuEditConfig)
        ] ^++^

        subKeys "Multimedia Keys"
        [ ("<XF86AudioMute>",         addName "Toggle mute"           $ volumeAdjust "togmute")
        , ("<XF86AudioLowerVolume>",  addName "Decrease volume"       $ volumeAdjust "down")
        , ("<XF86AudioRaiseVolume>",  addName "Increase volume"       $ volumeAdjust "up")
        , ("<XF86MonBrightnessDown>", addName "Decrease brightness"   $ spawn "backlightS -dec 10")
        , ("<XF86MonBrightnessUp>",   addName "Increase brightness"   $ spawn "backlightS -inc 10")
        , ("<XF86TouchpadToggle>",    addName "Toggle Touchpad"       $ spawn "toggleTouchpadS")
        , ("<Print>",                 addName "Take screenshot"       $ spawn (myPrintScreen ++ " -n"))
        , ("S-<Print>",               addName "Take screenshot menu"  $ spawn myPrintScreen)
        , ("M-u p",                   addName "Play music"            $ spawn "mpc play")
        , ("M-u ,",                   addName "Play next"             $ spawn "mpc next")
        , ("M-u .",                   addName "Play previous"         $ spawn "mpc prev")
        , ("M-u <Space>",             addName "Toggle play"           $ spawn "mpc toggle")
        , ("M-u n",                   addName "Fetch TV url"          $ spawn "newseries -p")
        , ("M-u /",                   addName "Music player"          $ namedScratchpadAction myScratchPads "myMusic")
        ] ^++^

        subKeys "Scratchpads"
        [ ("M-C-<Return>", addName "Scratchpads"    $ namedScratchpadAction myScratchPads "scratchpad")
        , ("M-`"         , addName "Scratchpad"     $ namedScratchpadAction myScratchPads "scratchpad")
        , ("M-z a"       , addName "Volume control" $ namedScratchpadAction myScratchPads "myPavu")
        , ("M-<F2>"      , addName "Volume control" $ namedScratchpadAction myScratchPads "myPavu")
        , ("M-z m"       , addName "Music player"   $ namedScratchpadAction myScratchPads "myMusic")
        , ("M-z w"       , addName "Whatsapp"       $ namedScratchpadAction myScratchPads "myWhatsApp")
        , ("M-z p"       , addName "Proton mail"    $ namedScratchpadAction myScratchPads "myProtonmail")
        ] ^++^

  #+end_src

  Prompts (=H-m=, man-page) and Search-engines(=H-s= +):

  - =g= S.google
  - =h= S.hoogle
  - =w= S.wikipedia
  - =a= archwiki
  - =n= news
  - =r= reddit
  - =u= urban
  - =c= S.hackage

  (Defined [[*src/Options.hs][here]])

  #+begin_src haskell -n
        subKeys "Prompts"
        [ ("M3-m", addName "Man-page Prompt" $ manPrompt myPromptTheme)] ^++^

        subKeys "Searchengines"
        [ ("M3-s " ++ k, addName "Search Engines"  $ S.promptSearch myPromptTheme f) | (k,f) <- searchList]

  #+end_src

  Keybinding to display the keybinding cheatsheet

  #+begin_src haskell -n
    myCheatsheetKey :: (KeyMask, KeySym)
    myCheatsheetKey = (myModMask .|. shiftMask, xK_slash)

  #+end_src

  Theme prompts:

  - Regular, for normal propmpts.
  - Warm, for projects
  - Hot, for Quitting and Killing

  #+begin_src haskell -n
    myPromptTheme :: XPConfig
    myPromptTheme = def
        { font                  = myFont
        , bgColor               = base03
        , fgColor               = active
        , fgHLight              = base03
        , bgHLight              = active
        , borderColor           = base03
        , promptBorderWidth     = 0
        , height                = prompt
        , promptKeymap          = emacsLikeXPKeymap
        , position              = Top
        -- , position            = CenteredAt { xpCenterY = 0.3, xpWidth = 0.3 }
        , historySize           = 256
        , historyFilter         = id
        , defaultText           = []
        -- , autoComplete        = Just 100000  -- set Just 100000 for .1 sec
        , showCompletionOnTab   = False
        -- , complCaseSensitivity  = ComplCaseSensitive False -- newer version :-(!
        , searchPredicate       = fuzzyMatch   --
        , sorter                = fuzzySort
        , defaultPrompter       = id $ map toUpper  -- change prompt to UPPER
        , alwaysHighlight       = True
        , maxComplRows          = Just 15 -- Nothing -- Nothing is unlimited
        }

    warmPromptTheme = myPromptTheme
        { bgColor               = yellow
        , fgColor               = base03
        , position              = Top
        }

    hotPromptTheme = myPromptTheme
        { bgColor               = red
        , fgColor               = base3
        , position              = Top
        }

  #+end_src

* src/MyBar.hs
  :PROPERTIES:
  :header-args: :tangle "~/.config/xmonad/src/MyBar.hs"
  :END:

  *Modules needed:*

  #+CAPTION: MyBar definition
  #+begin_src haskell -n
module MyBar
-- (spawnBarWithHandle, myBarAutostart, myLogHook)
where

import XMonad

import XMonad.Hooks.DynamicLog
import System.IO (Handle,hPutStrLn)

import Options

  #+end_src

  #+CAPTION: myLoghook
  #+begin_src haskell -n
myLogHook :: Handle -> X ()
myLogHook h = dynamicLogWithPP $ xmobarPP
                  { ppOutput          = hPutStrLn h
                  , ppTitle           = xmobarColor active "" . shorten 50
                  , ppVisible         = xmobarColor base0  "" . wrap "(" ")" . xmobarIcon
                  , ppUrgent          = xmobarColor red    "" . wrap " " " "
                  , ppSep             = xmobarColor red myNormalBorderColor " . "
                  , ppWsSep           = " "
                  , ppLayout          = xmobarColor yellow "" . xmobarLay
                  , ppOrder           = id
                  -- Format the workspace information
                  -- , ppCurrent         = xmobarColor active "" . wrap "[" "]"
                  , ppCurrent         = xmobarColor' active   "" . wrap "[" "]"
                  , ppHidden          = xmobarColor' inactive ""
                  -- , ppHiddenNoWindows = const ""
                  , ppHiddenNoWindows = xmobarColor inactive "" . myEmptyWsSymbol
                  }

#+end_src

Symbols used are from [[https://fontawesome.com/icons][fontawesome]].

Code is partly based on snippets from [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/src/XMonad.Hooks.DynamicLog.html][here]], which is the most understandable Haskell I've read so far.

#+Caption: Replacing long project names with symbols and icons
#+begin_src haskell -n
-- Symbols for displaying workspaces in xmobar
-- Must be functions, as it expects a different symbol for each
myCurrentWsSymbol workspaceName = "[●]" -- The workspace currently active
myHiddenWsSymbol  workspaceName =  "●"  -- Workspaces with open windows
myEmptyWsSymbol   workspaceName =  "○"  -- Workspaces with no windows

-- Show scratchpads, just with another color
xmobarColor' :: String  -- ^ foreground color: a color name, or #rrggbb format
             -> String  -- ^ background color
             -> String  -- ^ output string
             -> String
xmobarColor' fg bg x = xmobarColor fg2 bg $ xmobarIcon x
              where fg2 = case x of
                      "NSP" -> unfocusColor
                      --"chat" -> red
                      _ -> fg

-- Use shorter indicators for the workspaces
xmobarIcon :: String -> String
xmobarIcon x = case (filter (/='[') $ filter (/=']') x) of
               "browsers" -> "<fn=1>\xf0ac</fn>"
               "emacs"    -> "<fn=1>\xf044</fn>"
               "xmonad"   -> "<fn=0>xm</fn>"
               "term"     -> "<fn=1>\xf044</fn>"
               "chat"     -> "<fn=1>\xf086</fn>"
               "scratch"  -> "<fn=1>\xf0ad</fn>"
               "media"    -> "<fn=1>\xf085</fn>"
               "docs"     -> "<fn=1>\xf19d</fn>"
               "tv"       -> "<fn=1>\xf008</fn>"
               "NSP"      -> "<fn=1>\xf249</fn>"
               _          -> x

-- Use shorter indicators for the layout
xmobarLay :: String -> String
xmobarLay x = case x of
               --"Tall"  -> "<fn=0>T</fn>"
               "Tall"    -> "<fn=1>\xf00b</fn>" -- th-list
               "Three"   -> "<fn=0>3</fn>"
               "Full"    -> "<fn=1>\xf0c8</fn>" -- square "<fn=0>F</fn>"
               "magnify" -> "<fn=1>\xf00e</fn>" -- search-plus
               "monocle" -> "<fn=1>\xf06e</fn>" -- eye
               "Tabs"    -> "<fn=1>\xf0db</fn>" -- columns
               --"Tabs"  -> "<fn=1>\xf03b</fn>"
               "grid"    -> "<fn=1>\xf009</fn>" -- th-grid
               "floats"  -> "<fn=1>\xf0c2</fn>" -- cloud
               _       -> x

#+end_src

* src/MyLayoutHook.hs
  :PROPERTIES:
  :header-args: :tangle "~/.config/xmonad/src/MyLayoutHook.hs"
  :END:

      Extending layouts for daily use:

    - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-WindowNavigation.html][XMonad.Layout.WindowNavigation]] -- WindowNavigation is an extension to allow easy navigation of a workspace. See here for the new key bindings. TODO alternative for =windows W.focusUp=
    - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-LimitWindows.html][XMonad.Layout.LimitWindows]] -- A layout modifier that limits the number of windows that can be =shown=. My screen is not all that big, more then four windows is silly in most cases. Notice that the layout =shows= four windows, the other ones are still there, just not shown!

    Magnifing a layout:

    - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-Magnifier.html][XMonad.Layout.Magnifier]] -- This is a layout modifier that will make a layout increase the size of the window that has focus.
    - [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-ResizableTile.html][XMonad.Layout.ResizableTile]] -- More useful tiled layout that allows you to change a width/height of window.

    I use this to flip back and forth between a video, playing at 2/3d of the screen and a terminal, also at 2/3d where I follow the lesson / video. Uses ref:resize and ref:magnify

    Floating windows

    [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-PerWorkspace.html#v:onWorkspace][XMonad.Layout.PerWorkspace]] -- Configure layouts on a per-workspace basis: use layouts and apply layout modifiers selectively, depending on the workspace.

  *Modules needed:*
  #+Caption: Layout modules
  #+begin_src haskell -n
{-# LANGUAGE NoMonomorphismRestriction, FlexibleContexts #-}

module MyLayoutHook
(myLayoutHook)
where

--Layouts
import XMonad.Layout.Tabbed
import XMonad.Layout.ThreeColumns
import XMonad.Layout.GridVariants (Grid(Grid))
import XMonad.Layout.Simplest
import XMonad.Layout.SimplestFloat
import XMonad.Layout.Tabbed
import XMonad.Layout.DwmStyle
import XMonad.Layout.Accordion
import XMonad.Layout.BinarySpacePartition (emptyBSP)
import XMonad.Layout.Decoration           (Decoration,
                                           DefaultShrinker)
import XMonad.Layout.Simplest             (Simplest)
import XMonad.Layout.Spiral

--Support
import XMonad.Layout.Master
import XMonad.Layout.Magnifier
import XMonad.Layout.LimitWindows (limitWindows, increaseLimit, decreaseLimit)

import XMonad.Hooks.ManageDocks (avoidStruts)
import XMonad.Layout

import XMonad.Layout.ToggleLayouts -- (ToggleLayout (..),(toggleLayouts)
import XMonad.Layout.MultiToggle
import XMonad.Layout.MultiToggle.Instances
-- import XMonad.Layout.MultiToggle.Instances (StdTransformers(NBFULL, MIRROR, NOBORDERS))

import XMonad.Layout.NoBorders --needed?

import XMonad.Layout.Renamed
import XMonad.Layout.ResizableTile
import XMonad.Layout.Spacing
import XMonad.Layout.Gaps
import XMonad.Layout.Fullscreen

import XMonad.Layout.PerWorkspace

import XMonad.Layout.ResizableTile
--variants
import           XMonad.Layout.LayoutModifier       (ModifiedLayout)
--

--


-- import XMonad.Layout.WindowNavigation


    --------------------------

--Misc
import XMonad.Layout.ShowWName

import Options

  #+end_src

  Layouts:
#+Caption: Layout definitions
#+begin_src haskell -n

tall    = renamed [Replace "Tall"]
        $ mySpacing
        $ avoidStruts
        $ ResizableTall 1 (3/100) (1/2) []
wide    = renamed [Replace "wide"]
        $ mySpacing
        $ avoidStruts
        $ Mirror tall
full    = renamed [Replace "full"]
        $ avoidStruts
        $ Full
three   = renamed [Replace "Three"]
        $ mySpacing
        $ avoidStruts
        $ ThreeColMid 1 (3/100) (1/2)
grid    = renamed [Replace "grid"]
         -- $ windowNavigation
         -- $ addTabs shrinkText myTabTheme
         -- $ subLayout [0,1,2] (smartBorders Simplest)
        $ limitWindows 4
         -- $ mySpacing
         -- $ mkToggle (single MIRROR)
        $ Grid (16/10)
tabs    = renamed [Replace "Tabs"]
        $ avoidStruts
        $ tabbed shrinkText myTabConfig
magnify = renamed [Replace "magnify"]
           -- $ windowNavigation
           -- $ addTabs shrinkText myTabTheme
           -- $ subLayout [0,1,2] (smartBorders Simplest)
        $ magnifier
           -- $ limitWindows 2
           -- $ mySpacing 8
        $ ResizableTall 1 (3/100) (1/2) []
floats  = renamed [Replace "floats"]
        -- $ windowNavigation
      -- $ addTabs shrinkText myTabTheme
             -- $ subLayout [] (smartBorders Simplest)
        $ limitWindows 20 simplestFloat
sTabbed = renamed [Replace "tabbed"]
        $ simpleTabbed
readLayout = renamed [Replace "2/3"] (dwmStyle shrinkText myTabConfig (mastered (1/100) (2/3) Accordion))
-- tabLayout :: ModifiedLayout (Decoration TabbedDecoration DefaultShrinker) Simplest Window
tabLayout = tabbed shrinkText myTabConfig
vimLayout = Mirror (mastered (1/100) (4/5) Accordion)
tiled = Tall nmaster delta ratio
delta = 3/100
ratio = 1/2
nmaster = 1

#+end_src

#+Caption: myLayoutHook
#+begin_src haskell -n
myLayoutHook = avoidStruts
             -- $ toggleLayouts zoom defaultLayouts
             $ smartBorders
             $ showWName'  myShowWNameTheme
             $ mkToggle (single NBFULL)
             $ mkToggle (single MIRROR)
             $ onWorkspace "emacs" Simplest
             -- $ onWorkspace wsWEB webLayouts
             $ defaultLayouts
             where
               --vidProj  = [wsPythonP, wsHaskell, wsMOV]
               --codeProj = [wsKBorgP, wsXmonadP]
               webLayouts  =          tall ||| three |||  tabs
               --codeLayouts = noBorders magnify ||| full ||| tall
               --maxLayouts  =          full ||| magnify
               defaultLayouts = tall
                                ||| readLayout
                                ||| tabLayout
                                ||| vimLayout
                                ||| tiled
                                ||| tabs
                                -- ||| sTabbed
                                ||| three
                                ||| Simplest
                                ||| full
                                ||| grid
                                ||| wide
                                ||| floats
                                ||| magnify

  #+end_src

#+Caption: Gaps and spacing
#+begin_src haskell -n
-- Gaps around and between windows
-- Changes only seem to apply if I log out then in again
-- Dimensions are given as (Border top bottom right left)
mySpacing = spacingRaw True                -- Only for >1 window
                       -- The bottom edge seems to look narrower than it is
                       (Border 0 15 10 10) -- Size of screen edge gaps
                       True                -- Enable screen edge gaps
                       (Border 5 5 5 5)    -- Size of window gaps
                       True                -- Enable window gaps

myTabConfig ::  Theme
myTabConfig = def { fontName            = myFont
                  , activeColor         = myTabActiveColor
                  , inactiveColor       = myTabInactiveColor
                  , activeBorderColor   = myTabActiveBorderColor
                  , inactiveBorderColor = myTabInactiveBorderColor
                  , activeTextColor     = myTabActiveTextColor
                  , inactiveTextColor   = myTabInactiveTextColor
                  }

#+end_src

  [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Layout-ShowWName.html][XMonad-Layout-ShowWName]]: This is a layout modifier that will show the workspace name (on entering a workspace). Especially usefull as I don't write workspace names in my bar. Every workspace name is a project, defined under [[*src/MyWorkspaces][src/MyWorkspaces]].

  #+Caption: ShowName configation
  #+begin_src haskell -n

myShowWNameTheme :: SWNConfig
myShowWNameTheme = def
    { swn_font              = myMediumFont
    , swn_fade              = 1.0
    , swn_bgcolor           = base03
    , swn_color             = base3
    }

  #+end_src

* src/MyManageHook.hs
  :PROPERTIES:
  :header-args: :tangle "~/.config/xmonad/src/MyManageHook.hs"
  :END:

  *Modules needed:*

  #+begin_src haskell -n
module MyManageHook
(myManageHook)
where

import Data.List (isInfixOf)
import Data.Ratio
import XMonad
import XMonad.Hooks.ManageDocks
import XMonad.Hooks.ManageHelpers
import qualified XMonad.StackSet as W

import MyScratchpads (myScratchPads)
import XMonad.Util.NamedScratchpad

  #+end_src

  Help functions:

  #+begin_src haskell -n
titleContains :: String -> Query Bool
titleContains string = fmap (isInfixOf string) title

isZoomNotification :: Query Bool
isZoomNotification = className =? "zoom" <&&> title =? "zoom"

  #+end_src

   **Window rules: Manage Hook**

   Execute arbitrary actions and WindowSet manipulations when managing
   a new window. You can use this to, for example, always float a
   particular program, or have a client always appear on a particular
   workspace.

   To find the property name associated with a program, use

   #+begin_example
   xprop | grep WM_CLASS
   #+end_example

   and click on the client you're interested in.

   *Update:* use [[*Xprop wrapper - xmonpropS][Xprop wrapper - xmonpropS]]

   To match on the WM_NAME, you can use 'title' in the same way that
   'className' and 'resource' are used below.

   The class name of an application corresponds to the first
   value of WM_CLASS (“Pidgin”).
   The resource corresponds to the second value of WM_CLASS (also “Pidgin”).
   The title corresponds to WM_NAME (“Buddy List”).

  #+begin_src haskell -n
manageSpecific :: ManageHook
manageSpecific = composeAll . concat $
    [ [ resource   =? c                     --> largeFloat | c <- floatApps ]

    , [ resource   =? "gsimplecal"          --> doFloatAt' (1554/1920) (30/1040) ]
    -- , [ className  =? c                     --> doShift ( myWorkspaces !! 0 )| c <- myBrowsers ] TODO IRC

    , [ role       =? "gimp-file-open"      --> doRectFloat (W.RationalRect 0.3 0.3 0.9 0.9) ]
    , [ className  =? "Gimp"                --> doCenterFloat]

    , [ className  =? "zoom" <&&> titleContains z --> doFloat | z <- myZoomFloats ]
    , [ isZoomNotification                        --> doFloat ]

    , [ className  =? "Chromium" <&&> role =? "GtkFileChooserDialog" --> largeFloat]
    , [ (title     =? "emacs-capture" )     --> smallFloat ]

    , [ (className =? "obs" <&&> title =? "Scripts" ) --> largeFloat ]
    , [ (className =? "obs" <&&> isDialog ) --> largeFloat ]
    ]
    where
        floatApps  = ["pavucontrol", "myMusic", "xmessage", "myFloat"]
        obsFloats  = [ "Scripts"]
        myZoomFloats   = ["Chat", "Participants", "Rooms"] -- Currently untested for breakout rooms
        role = stringProperty "WM_WINDOW_ROLE"
        doMaster = doF W.shiftMaster --append this to all floats so new windows always go on top, regardless of the current focus
        doFloatAt' x y = doFloatAt x y <+> doMaster

myManageHook :: ManageHook
myManageHook = manageSpecific <+> manageDocks  <+> namedScratchpadManageHook myScratchPads

  #+end_src

  #+begin_src haskell -n
largeFloat :: ManageHook
largeFloat = doFloatDep move
  where
    move :: W.RationalRect -> W.RationalRect
    move _ = W.RationalRect x y w h
    w, h, x, y :: Rational
    w = 3/4
    h = 3/4
    x = (1-w)/2
    y = (1-h)/2


smallFloat :: ManageHook
smallFloat = doFloatDep move
  where
    move :: W.RationalRect -> W.RationalRect
    move _ = W.RationalRect x y w h
    w, h, x, y :: Rational
    w = 2/3
    h = 1/4
    x = (1-w)/2
    y = (1-h)/2

zoomFloat :: ManageHook
zoomFloat = doFloatDep move
  where
    move :: W.RationalRect -> W.RationalRect
    move _ = W.RationalRect x y w h
    w, h, x, y :: Rational
    w = 1/4
    h = 1/4
    x = (1-w)/2
    y = (1-h)/2

  #+end_src

* src/MyCheatsheet
  :PROPERTIES:
  :header-args:  :tangle "~/.config/xmonad/src/MyCheatsheet.hs"
  :END:

  - Source: [[https://github.com/quarkQuark/dotfiles/tree/49ab839c7c8ad33c728a1238a2af9ce860abe5dc/.config/xmonad][github.com/quarkQuark/dotfiles]]

  *Modules needed:*

  #+begin_src haskell -n
    module MyCheatsheet
    (myCheatsheet)
    where

    import Data.List.Split (chunksOf)
    import System.IO
    import Test.FitSpec.PrettyPrint (columns) -- Requires the 'fitspec' package
    import XMonad
    import XMonad.Util.NamedActions
    import XMonad.Util.Run

  #+end_src

  Pipe key bindings to dzen2:

  #+begin_src haskell -n
    -- Number of colomns with with which to display the cheatsheet
    myCheatsheetCols :: Int
    myCheatsheetCols = 3

    -- Format the keybindings so they can be sent to the display
    formatList :: [String] -> String
    formatList list = columns "SeparatorPlaceholder" -- Normalise column widths -> Table
                    $ map unlines -- Connect the sublists with line breaks -> [column1,column2,...]
                    $ chunksOf (myCheatsheetRows (list))
                    $ list -- The list to be formatted

            where rowsFromColumns list nCol = 1 + length list `div` nCol
                  myCheatsheetRows list = rowsFromColumns list myCheatsheetCols

    -- How to display the cheatsheet (adapted from Ethan Schoonover's config)
    myCheatsheet :: [((KeyMask, KeySym), NamedAction)] -> NamedAction
    myCheatsheet myKeyList = addName "Show Keybindings" $ io $ do
        handle <- spawnPipe "dzen2-display-cheatsheetS"
        hPutStrLn handle "TitlePlaceholder\n" -- Replaced in the script
        hPutStrLn handle $ formatList (showKm myKeyList)
        hClose handle
        return ()

  #+end_src

  Script: =dzen2-display-cheatsheetS=

  #+begin_src shell :tangle-mode (identity #o555) :tangle "~/.local/bin/dzen2-display-cheatsheetS"
    #!/usr/bin/sh

    font="Mono-10"

    # Colours
    background='#000000'
    titleColour='^fg(#00AAAA)'
    asideColour='^fg(#666666)'
    headingColour='^fg(#FFFFFF)'
    keyColourSuper='^fg(#AAAA00)'
    keyColourHyper='^fg(#AA88FF)'
    keyColourMedia='^fg(#FF8888)'
    descColour='^fg(#AAAAAA)'

    # Patterns to replace
    keyLinesSuper='\(M4-\|Super\)[^ ]*'
    keyLinesHyper='M3-[^ ]*'
    keyLinesMedia='\(Print\|XF86\|C-\)[^ ]*'
    headings='>>'

    # Replacement Variables
    super="${keyColourSuper}Super(Windows\/Space)${titleColour}"
    hyper="${keyColourHyper}Hyper(Caps Lock)${titleColour}"
    title="${titleColour}XMonad Keybindings (with the $super or $hyper key)"\
    "${asideColour}        -    Click to close"

    # Screen dimensions, for positioning calculations
    screenXY=`xdpyinfo | awk '/dimensions:/ { print $2 }'`
    screenX=${screenXY%x*}
    screenY=${screenXY#*x}

    # Dimensions
    lineHeight=24
    lines=42
    replaceSeparator="s/SeparatorPlaceholder/    /g"
    width=1800
    height=`expr ${lineHeight} \* \( ${lines} + 1 \)`

    # Position
    xPos=`expr \( ${screenX} - ${width} \) / 2`
    yPos=`expr \( ${screenY} - ${height} \) / 2`

    # Dzen behaviour
    eventActions='onstart=uncollapse'\
    ';button1=exit;button3=exit;key_Escape=exit'\
    ';button4=scrollup;button5=scrolldown'

    # Replace placeholders
    replaceTitle="s/TitlePlaceholder/${title}/g"
    replaceSuperTap="s/C-Escape/Super   /g"
    replaceShift="s/Shift-\([^ ]*\)/S-\1    /g"
    replaceSlash="s/slash/\/    /g"
    replacePlaceholders="${replaceTitle};${replaceM4};${replaceSuperTap}
    ;${replaceShift};${replaceSlash};${replaceSeparator}"

    # Format colour
    colourKeyLinesSuper="s/${keyLinesSuper}/${keyColourSuper}&${descColour}/g"
    colourKeyLinesHyper="s/${keyLinesHyper}/${keyColourHyper}&${descColour}/g"
    colourKeyLinesMedia="s/${keyLinesMedia}/${keyColourMedia}&${descColour}/g"
    colourHeadings="s/${headings}/${headingColour}&/g"
    formatColour="${colourKeyLinesSuper};${colourKeyLinesHyper};${colourKeyLinesMedia};${colourHeadings}"

    # Remove redundancies
    removeM4="s/M4-\([^ ]*\)/\1   /g"
    removeM3="s/M3-\([^ ]*\)/\1   /g"
    screen="s/ S \(.\)/ \1  /g"
    removeRedundancies="${removeM4};${removeM3};${screen}"

    addMargin="/[^<${title}>]/s/^/  /g"

    sed "${replacePlaceholders};${formatColour};${addMargin};${removeRedundancies}" \
        | dzen2 -p \
                -bg $background \
                -h "$lineHeight" -w "$width" -l "$lines" \
                -x "$xPos" -y "$yPos" \
                -fn $font \
                -e $eventActions

  #+end_src
* src/MyScratchpads
  :PROPERTIES:
  :header-args:  :tangle "~/.config/xmonad/src/MyScratchpads.hs"
  :END:

  [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Util-NamedScratchpad.html][XMonad.Util.NamedScratchpad]] --

  *Modules needed:*

  #+begin_src haskell -n
    module MyScratchpads
    (myScratchPads)
    where

    import XMonad
    import Options
    import XMonad.Util.NamedScratchpad
    import qualified XMonad.StackSet as W
  #+end_src

  #+begin_src haskell -n
    ---------------------------------------------------------------------------
    -- SCRATCHPADS                                                           --
    ---------------------------------------------------------------------------
    myScratchPads :: [NamedScratchpad]
    myScratchPads = [ NS "scratchpad" spawnTerm findTerm manageTerm
                    , NS "myPavu" spawnPavu findPavu managePavu
                    , NS "myMusic" spawnMocp findMocp manageMocp
                    , NS "myWhatsApp" spawnWhatsApp findWhatsApp manageWhatsApp
                    , NS "myProtonmail" spawnProtonmail findProtonmail manageProtonmail
                    ]
      where
        spawnTerm  = myTerminal ++ " --class scratchPad"
        findTerm   = resource =? "scratchPad"
        manageTerm = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.6
                     w = 0.9
                     t = 1 - h     -- bottom edge
                     l = (1 - w)/2 -- centered left/right
        spawnPavu  = myAudiocontrol ++ " --class myPavu"
        findPavu   = resource =? "pavucontrol" --TODO how to catch second field?
        managePavu = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.7
                     w = 0.7
                     t = (1 - h)/2 -- centered top/bottom
                     l = (1 - w)/2 -- centered left/right
        spawnMocp  = "alacritty --class myMusic -e ncmpcpp"
        findMocp   = resource =? "myMusic"
        manageMocp = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.9
                     w = 0.9
                     t = 0.95 -h
                     l = 0.95 -w
        spawnWhatsApp  = "chromium --app=https://web.whatsapp.com/"
        findWhatsApp   = appName =? "web.whatsapp.com"
        manageWhatsApp = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.9
                     w = 0.9
                     t = 0.95 -h
                     l = 0.95 -w
        spawnProtonmail  = "chromium --app=https://mail.protonmail.com/"
        findProtonmail   = appName =? "mail.protonmail.com"
        manageProtonmail = customFloating $ W.RationalRect l t w h
                   where
                     h = 0.9
                     w = 0.9
                     t = 0.95 -h
                     l = 0.95 -w
  #+end_src
* src/MyWorkspaces
  :PROPERTIES:
  :header-args:  :tangle "~/.config/xmonad/src/MyWorkspaces.hs"
  :END:

  [[https://hackage.haskell.org/package/xmonad-contrib-0.16/docs/XMonad-Actions-DynamicProjects.html][XMonad.Actions.DynamicProjects]] -- (From the documentation:) Imbues workspaces with additional features so they can be treated as individual project areas.

  Instead of using generic workspace names such as 3 or work, DynamicProjects allows you to dedicate workspaces to specific projects and then switch between projects easily.

  A project is made up of a name, working directory, and a start-up hook. When you switch to a workspace, DynamicProjects changes the working directory to the one configured for the matching project. If the workspace doesn't have any windows, the project's start-up hook is executed. This allows you to launch applications or further configure the workspace/project.

  When using the switchProjectPrompt function, workspaces are created as needed. This means you can create new project spaces (and therefore workspaces) on the fly. (These dynamic projects are not preserved across restarts.)

  *Modules needed:*

  #+Caption: Workspace modules
  #+begin_src haskell -n
  module MyWorkspaces
    ( projects,
      names
    )
  where

  import XMonad
  import XMonad.Actions.DynamicProjects
  import XMonad.Layout.LayoutCombinators (JumpToLayout (..))
  import XMonad.Util.SpawnOnce

  import Options                                                -- local settings
  #+end_src

  To set up a new =project=, use the following template:

  #+Caption: Project template
  #+begin_example haskell
      { projectName = "browsers",              (1)
        projectDirectory = "~/Downloads",      (2)
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tall")    (3)
          spawn "qutebrowser"                  (4)
      },
  #+end_example

  1. =Project name= this field is used to switch to the workspace, and in the notification area (if not overwritten with an icon)
  2. =Project directory=
  3. Default layout
  4. Using /spawn/ start default applications in /that/ workspace. Terminals will open by default in the directory set in (2)

  TODO class needed?

  **Key bindings** - [[Project keys][Project keys]]

  =Super+<number>= is set to the first ten projects, the others can be reached by =Super-w=.

  #+Caption: My projects
  #+begin_src haskell -n
  projects :: [Project]
  projects =
    [ Project
      { projectName = "browsers",
        projectDirectory = "~/Downloads",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tall")
          spawn "qutebrowser"
      },
      Project
      { projectName = "emacs",
        projectDirectory = "~/",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tall")
          spawn "emacsclient -c"
      },
      Project
      { projectName = "xmonad",
        projectDirectory = "~/Projects/WS",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tall")
          spawn "alacritty"
      },
      Project
      { projectName = "term",
        projectDirectory = "~/",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tall")
          spawn "alacritty"
      },
      Project
      { projectName = "scratch",
        projectDirectory = "~/Desktop",
        projectStartHook = Nothing
      },
      Project
      { projectName = "chat",
        projectDirectory = "~/Downloads",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tall")
          spawn "alacritty -e tmux attach"
          spawn "alacritty"
      },
      Project
      { projectName = "docs",
        projectDirectory = "~/Documents/",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tall")
          spawn "alacritty"
      },
      Project
      { projectName = "tv",
        projectDirectory = "~/Video",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "Tabbed")
          -- spawn "alaritty -e ranger"
          spawn (myTerminal ++ " -t tv2 --class tv -e ranger")
      }
      Project
      { projectName = "zoom",
        projectDirectory = "~/Downloads",
        projectStartHook = Just $ do
          sendMessage (JumpToLayout "2/3")
          spawn "zoom"
          spawn (myTerminal ++ " --class zoom")
      }
    ]

  #+end_src

  #+Caption: Workspace helper scripts
  #+begin_src haskell -n
  -- | Names of my workspaces.
  names :: [WorkspaceId]
  names = map projectName projects

  -- | open terminal in current project environment (unsafeSpawn)
  projRunInTerm :: String -> String -> X ()
  projRunInTerm options command = asks (terminal . config) >>= \t -> unsafeSpawn $ t ++ " " ++ " --class " ++ activateProject  ++ options ++ " -e " ++ command
  #+end_src

* External scripts
** src/autostartS
   Still haven't figured out what's best. Atm I use .xinitrc for most of this.

   #+begin_src shell :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.config/xmonad/src/autostartS"
     echo "src/autostartS started - $(date)" >> ~/tmp/xmonad.log
     wallpaper

     if [ -z "$(pgrep unclutter)" ] ; then
         unclutter --timeout 4 --jitter 10 --ignore-scrolling -b
     fi

     if [ -z "$(pgrep dunst)" ] ; then
         dunst &
     fi

     if [ -z "$(pgrep picom)" ] ; then
         picom &
     fi

     if [ -z "$(pgrep redshift)" ] ; then
         redshift &
     fi

     # Daemons
     #emacs --daemon & Started with systemd
     #udiskie &
     #nm-applet --indicator &
     #lxqt-powermanagement &

     # Settings
     xrdb -merge "$HOME/.config/X11/Xresources" &
     #xmodmap -e 'add mod3 = Menu'
     #xmodmap -e "keycode 135 = Hyper_R"
     #xmodmap -e "add mod3 = Hyper_R"
     #xmodmap -e "keycode any = Menu" # this is needed for xcape
     #xcape -e "Hyper_R=Menu" # for single key press on menu key
     setxkbmap -model pc105 -layout us,ru -variant ,phonetic -option grp:shifts_toggle -option ctrl:nocaps # -option compose:menu
     xmodmap ~/.config/X11/Xmodmap

     xsetroot -grey -cursor_name left_ptr &

   #+end_src

   #+RESULTS:

** WM scripts
*** Xprop wrapper - xmonpropS

    Source: [[https://wiki.haskell.org/Xmonad/Frequently_asked_questions#I_need_to_find_the_class_title_or_some_other_X_property_of_my_program][Haskell wiki]]

     #+begin_src shell :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.local/bin/xmonPropS"

       exec xprop -notype \
        -f WM_NAME        8s ':\n  title =\? $0\n' \
        -f WM_CLASS       8s ':\n  appName =\? $0\n  className =\? $1\n' \
        -f WM_WINDOW_ROLE 8s ':\n  stringProperty "WM_WINDOW_ROLE" =\? $0\n' \
        WM_NAME WM_CLASS WM_WINDOW_ROLE \
        ${1+"$@"}

    #+end_src

*** Keyboard indicator Mobar
    #+begin_src  shell :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.local/bin/myKbS"
      stdlayout=us  # standard layout takes "default" color
      stdname=en-us # arbitrary, descriptive only

      base03=#002b36
      base02=#073642
      base01=#586e75
      base00=#657b83
      base0=#839496
      base1=#93a1a1
      base2=#eee8d5
      base3=#fdf6e3
      yellow=#b58900
      orange=#cb4b16
      red=#dc322f
      magenta=#d33682
      violet=#6c71c4
      blue=#268bd2
      cyan=#2aa198
      green=#859900

      layout="$(~/.local/bin/xkblayout-state print "%s")"

      case $layout in
          ${stdlayout}) color=$green; icon=" "; name=$stdname ;; # f11c fa-keyboard-o
          ,*) color=$magenta; icon=" "; name="russian" ;; # f11c fa-keyboard-o
      esac

      echo "<fc=$color><fn=1>$icon</fn> ${name}</fc>"
    #+end_src

*** adjustVolumeS

    Pulseaudio version, huge, see =adjustVolumeS help=.

    #+begin_src shell  :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.local/bin/adjustVolumeS"

##################################################################
# Polybar Pulseaudio Control                                     #
# https://github.com/marioortizmanero/polybar-pulseaudio-control #
##################################################################
#
# Broken by QWxlea

# Defaults for configurable values, expected to be set by command-line arguments
msgId="991001"
AUTOSYNC="no"
COLOR_MUTED="%{F#6b6b6b}"
ICON_MUTED=
ICON_SINK=
NOTIFICATIONS="no"
OSD="yes"
SINK_NICKNAMES_PROP=
VOLUME_STEP=2
VOLUME_MAX=130
# shellcheck disable=SC2016
FORMAT='$VOL_ICON ${VOL_LEVEL}%  $ICON_SINK $SINK_NICKNAME'
declare -A SINK_NICKNAMES
declare -a ICONS_VOLUME
declare -a SINK_BLACKLIST

# Environment & global constants for the script
END_COLOR="%{F-}"  # For Polybar colors
LANGUAGE=en_US  # Some calls depend on English outputs of pactl


# Saves the currently default sink into a variable named `curSink`. It will
# return an error code when pulseaudio isn't running.
function getCurSink() {
    if ! pulseaudio --check; then return 1; fi
    curSink=$(pacmd list-sinks | awk '/\* index:/{print $3}')
}


# Saves the sink passed by parameter's volume into a variable named `VOL_LEVEL`.
function getCurVol() {
    VOL_LEVEL=$(pacmd list-sinks | grep -A 15 'index: '"$1"'' | grep 'volume:' | grep -E -v 'base volume:' | awk -F : '{print $3; exit}' | grep -o -P '.{0,3}%' | sed 's/.$//' | tr -d ' ')
}


# Saves the name of the sink passed by parameter into a variable named
# `sinkName`.
function getSinkName() {
    sinkName=$(pactl list sinks short | awk -v sink="$1" '{ if ($1 == sink) {print $2} }')
}


# Saves the name to be displayed for the sink passed by parameter into a
# variable called `SINK_NICKNAME`.
# If a mapping for the sink name exists, that is used. Otherwise, the string
# "Sink #<index>" is used.
function getNickname() {
    getSinkName "$1"
    unset SINK_NICKNAME

    if [ -n "$sinkName" ] && [ -n "${SINK_NICKNAMES[$sinkName]}" ]; then
        SINK_NICKNAME="${SINK_NICKNAMES[$sinkName]}"
    elif [ -n "$sinkName" ] && [ -n "$SINK_NICKNAMES_PROP" ]; then
        getNicknameFromProp "$SINK_NICKNAMES_PROP" "$sinkName"
        # Cache that result for next time
        SINK_NICKNAMES["$sinkName"]="$SINK_NICKNAME"
    fi

    if [ -z "$SINK_NICKNAME" ]; then
        SINK_NICKNAME="Sink #$1"
    fi
}

# Gets sink nickname based on a given property.
function getNicknameFromProp() {
    local nickname_prop="$1"
    local for_name="$2"

    SINK_NICKNAME=
    while read -r property value; do
        case "$property" in
            name:)
                sink_name="${value//[<>]/}"
                unset sink_desc
                ;;
            "$nickname_prop")
                if [ "$sink_name" != "$for_name" ]; then
                    continue
                fi
                SINK_NICKNAME="${value:3:-1}"
                break
                ;;
        esac
    done < <(pacmd list-sinks)
}

# Saves the status of the sink passed by parameter into a variable named
# `isMuted`.
function getIsMuted() {
    isMuted=$(pacmd list-sinks | grep -A 15 "index: $1" | awk '/muted/ {print $2; exit}')
}


# Saves all the sink inputs of the sink passed by parameter into a string
# named `sinkInputs`.
function getSinkInputs() {
    sinkInputs=$(pacmd list-sink-inputs | grep -B 4 "sink: $1 " | awk '/index:/{print $2}')
}


function volUp() {
    # Obtaining the current volume from pacmd into $VOL_LEVEL.
    if ! getCurSink; then
        echo "PulseAudio not running"
        return 1
    fi
    getCurVol "$curSink"
    local maxLimit=$((VOLUME_MAX - VOLUME_STEP))

    # Checking the volume upper bounds so that if VOLUME_MAX was 100% and the
    # increase percentage was 3%, a 99% volume would top at 100% instead
    # of 102%. If the volume is above the maximum limit, nothing is done.
    if [ "$VOL_LEVEL" -le "$VOLUME_MAX" ] && [ "$VOL_LEVEL" -ge "$maxLimit" ]; then
        pactl set-sink-volume "$curSink" "$VOLUME_MAX%"
    elif [ "$VOL_LEVEL" -lt "$maxLimit" ]; then
        pactl set-sink-volume "$curSink" "+$VOLUME_STEP%"
    fi

    if [ $OSD = "yes" ]; then showOSD "$curSink"; fi
    if [ $AUTOSYNC = "yes" ]; then volSync; fi
}


function volDown() {
    # Pactl already handles the volume lower bounds so that negative values
    # are ignored.
    if ! getCurSink; then
        echo "PulseAudio not running"
        return 1
    fi
    pactl set-sink-volume "$curSink" "-$VOLUME_STEP%"

    if [ $OSD = "yes" ]; then showOSD "$curSink"; fi
    if [ $AUTOSYNC = "yes" ]; then volSync; fi
}


function volSync() {
    if ! getCurSink; then
        echo "PulseAudio not running"
        return 1
    fi
    getSinkInputs "$curSink"
    getCurVol "$curSink"

    # Every output found in the active sink has their volume set to the
    # current one. This will only be called if $AUTOSYNC is `yes`.
    for each in $sinkInputs; do
        pactl set-sink-input-volume "$each" "$VOL_LEVEL%"
    done
}


function volMute() {
    # Switch to mute/unmute the volume with pactl.
    if ! getCurSink; then
        echo "PulseAudio not running"
        return 1
    fi
    if [ "$1" = "toggle" ]; then
        getIsMuted "$curSink"
        if [ "$isMuted" = "yes" ]; then
            pactl set-sink-mute "$curSink" "no"
        else
            pactl set-sink-mute "$curSink" "yes"
        fi
    elif [ "$1" = "mute" ]; then
        pactl set-sink-mute "$curSink" "yes"
    elif [ "$1" = "unmute" ]; then
        pactl set-sink-mute "$curSink" "no"
    fi

    if [ $OSD = "yes" ]; then showOSD "$curSink"; fi
}


function nextSink() {
    # The final sinks list, removing the blacklisted ones from the list of
    # currently available sinks.
    if ! getCurSink; then
        echo "PulseAudio not running"
        return 1
    fi

    # Obtaining a tuple of sink indexes after removing the blacklisted devices
    # with their name.
    sinks=()
    local i=0
    while read -r line; do
        index=$(echo "$line" | cut -f1)
        name=$(echo "$line" | cut -f2)

        # If it's in the blacklist, continue the main loop. Otherwise, add
        # it to the list.
        for sink in "${SINK_BLACKLIST[@]}"; do
            if [ "$sink" = "$name" ]; then
                continue 2
            fi
        done

        sinks[$i]="$index"
        i=$((i + 1))
    done < <(pactl list short sinks)

    # If the resulting list is empty, nothing is done
    if [ ${#sinks[@]} -eq 0 ]; then return; fi

    # If the current sink is greater or equal than last one, pick the first
    # sink in the list. Otherwise just pick the next sink avaliable.
    local newSink
    if [ "$curSink" -ge "${sinks[-1]}" ]; then
        newSink=${sinks[0]}
    else
        for sink in "${sinks[@]}"; do
            if [ "$curSink" -lt "$sink" ]; then
                newSink=$sink
                break
            fi
        done
    fi

    # The new sink is set
    pacmd set-default-sink "$newSink"

    # Move all audio threads to new sink
    local inputs
    inputs="$(pactl list short sink-inputs | cut -f 1)"
    for i in $inputs; do
        pacmd move-sink-input "$i" "$newSink"
    done

    if [ $NOTIFICATIONS = "yes" ]; then
        getNickname "$newSink"

        if command -v dunstify &>/dev/null; then
            notify="dunstify --replace 201839192"
        else
            notify="notify-send"
        fi
        $notify "PulseAudio" "Changed output to $SINK_NICKNAME" --icon=audio-headphones-symbolic &
    fi
}


# This function assumes that PulseAudio is already running. It only supports
# KDE OSDs for now. It will show a system message with the status of the
# sink passed by parameter, or the currently active one by default.
function showOSD() {
    if [ -z "$1" ]; then
        curSink="$1"
    else
        getCurSink
    fi
    getCurVol "$curSink"
    getIsMuted "$curSink"
    #returns "$VOL_LEVEL" "$isMuted"
    if [[ $VOL_LEVEL == 0 || "yes" = "$isMuted" ]]; then
        # Show the sound muted notification
        echo "nope"
        dunstify -a "changeVolume" -u low -i audio-volume-muted -r "$msgId" "Volume muted"
    else
        # Show the volume notification
        if [ $VOL_LEVEL -lt 30 ];then
            ICON="audio-volume-low"
        elif [ $VOL_LEVEL -lt 65 ];then
            ICON="audio-volume-medium"
        elif [ $VOL_LEVEL -lt 100 ];then
            ICON="audio-volume-high"
        else
            ICON="audio-volume-overamplified"
        fi

        dunstify -a "changeVolume" -u low -i "$ICON" -r "$msgId" \
                 "Volume: ${VOL_LEVEL}%" "$(getProgressStringS 10 "<b> </b>" " " $VOL_LEVEL)"
    fi
    #echo "DB: vol_level:($VOL_LEVEL) isMuted: ($isMuted)"
}


function listen() {
    local firstRun=0

    # Listen for changes and immediately create new output for the bar.
    # This is faster than having the script on an interval.
    LANG=$LANGUAGE pactl subscribe 2>/dev/null | {
        while true; do
            {
                # If this is the first time just continue and print the current
                # state. Otherwise wait for events. This is to prevent the
                # module being empty until an event occurs.
                if [ $firstRun -eq 0 ]; then
                    firstRun=1
                else
                    read -r event || break
                    # Avoid double events
                    if ! echo "$event" | grep -e "on card" -e "on sink" -e "on server"; then
                        continue
                    fi
                fi
            } &>/dev/null
            output
        done
    }
}


function output() {
    if ! getCurSink; then
        echo "PulseAudio not running"
        return 1
    fi
    getCurVol "$curSink"
    getIsMuted "$curSink"

    # Fixed volume icons over max volume
    local iconsLen=${#ICONS_VOLUME[@]}
    if [ "$iconsLen" -ne 0 ]; then
        local volSplit=$((VOLUME_MAX / iconsLen))
        for i in $(seq 1 "$iconsLen"); do
            if [ $((i * volSplit)) -ge "$VOL_LEVEL" ]; then
                VOL_ICON="${ICONS_VOLUME[$((i-1))]}"
                break
            fi
        done
    else
        VOL_ICON=""
    fi

    getNickname "$curSink"

    # Showing the formatted message
    if [ "$isMuted" = "yes" ]; then
        # shellcheck disable=SC2034
        VOL_ICON=$ICON_MUTED
        echo "${COLOR_MUTED}$(eval echo "$FORMAT")${END_COLOR}"
    else
        eval echo "$FORMAT"
    fi
}


function usage() {
    echo "\
Usage: $0 [OPTION...] ACTION

Options: [defaults]
  --autosync | --no-autosync            whether to maintain same volume for all
                                        programs [$AUTOSYNC]
  --color-muted <rrggbb>                color in which to format when muted
                                        [${COLOR_MUTED:4:-1}]
  --notifications | --no-notifications  whether to show notifications when
                                        changing sinks [$NOTIFICATIONS]
  --osd | --no-osd                      whether to display KDE's OSD message
                                        [$OSD]
  --icon-muted <icon>                   icon to use when muted [none]
  --icon-sink <icon>                    icon to use for sink [none]
  --format <string>                     use a format string to control the output
                                        Available variables: \$VOL_ICON,
                                        \$VOL_LEVEL, \$ICON_SINK, and
                                        \$SINK_NICKNAME
                                        [$FORMAT]
  --icons-volume <icon>[,<icon>...]     icons for volume, from lower to higher
                                        [none]
  --volume-max <int>                    maximum volume to which to allow
                                        increasing [$VOLUME_MAX]
  --volume-step <int>                   step size when inc/decrementing volume
                                        [$VOLUME_STEP]
  --sink-blacklist <name>[,<name>...]   sinks to ignore when switching [none]
  --sink-nicknames-from <prop>          pacmd property to use for sink names,
                                        unless overriden by --sink-nickname.
                                        Its possible values are listed under
                                        the 'properties' key in the output of
                                        \`pacmd list-sinks\` [none]
  --sink-nickname <name>:<nick>         nickname to assign to given sink name,
                                        taking priority over
                                        --sink-nicknames-from. May be given
                                        multiple times, and 'name' is exactly as
                                        listed in the output of
                                        \`pactl list sinks short | cut -f2\`
                                        [none]

Actions:
  help              display this message and exit
  output            print the PulseAudio status once
  listen            listen for changes in PulseAudio to automatically update
                    this script's output
  up, down          increase or decrease the default sink's volume
  mute, unmute      mute or unmute the default sink's audio
  togmute           switch between muted and unmuted
  next-sink         switch to the next available sink
  sync              synchronize all the output streams volume to be the same as
                    the current sink's volume

Author:
    Mario Ortiz Manero
More info on GitHub:
    https://github.com/marioortizmanero/polybar-pulseaudio-control"
}

while [[ "$1" = --* ]]; do
    unset arg
    unset val
    if [[ "$1" = *=* ]]; then
        arg="${1//=*/}"
        val="${1//*=/}"
        shift
    else
        arg="$1"
        # Support space-separated values, but also value-less flags
        if [[ "$2" != --* ]]; then
            val="$2"
            shift
        fi
        shift
    fi

    case "$arg" in
        --autosync)
            AUTOSYNC=yes
            ;;
        --no-autosync)
            AUTOSYNC=no
            ;;
        --color-muted|--colour-muted)
            COLOR_MUTED="%{F#$val}"
            ;;
        --notifications)
            NOTIFICATIONS=yes
            ;;
        --no-notifications)
            NOTIFICATIONS=no
            ;;
        --osd)
            OSD=yes
            ;;
        --no-osd)
            OSD=no
            ;;
        --icon-muted)
            ICON_MUTED="$val"
            ;;
        --icon-sink)
            # shellcheck disable=SC2034
            ICON_SINK="$val"
            ;;
        --icons-volume)
            IFS=, read -r -a ICONS_VOLUME <<< "$val"
            ;;
        --volume-max)
            VOLUME_MAX="$val"
            ;;
        --volume-step)
            VOLUME_STEP="$val"
            ;;
        --sink-blacklist)
            IFS=, read -r -a SINK_BLACKLIST <<< "$val"
            ;;
        --sink-nicknames-from)
            SINK_NICKNAMES_PROP="$val"
            ;;
        --sink-nickname)
            SINK_NICKNAMES["${val//:*/}"]="${val//*:}"
            ;;
        --format)
            FORMAT="$val"
            ;;
        ,*)
            echo "Unrecognised option: $arg" >&2
            exit 1
            ;;
    esac
done

case "$1" in
    up)
        volUp
        ;;
    down)
        volDown
        ;;
    togmute)
        volMute toggle
        ;;
    mute)
        volMute mute
        ;;
    unmute)
        volMute unmute
        ;;
    sync)
        volSync
        ;;
    listen)
        listen
        ;;
    next-sink)
        nextSink
        ;;
    output)
        output
        ;;
    help)
        usage
        ;;
    ,*)
        echo "Unrecognised action: $1" >&2
        exit 1
        ;;
esac
    #+end_src

    Alsa version, sometimes got stuck, unused

    #+begin_src shell
# changeVolume
# Source: https://wiki.archlinux.org/index.php/Dunst#Appearance

# Arbitrary but unique message id
msgId="991049"

# Change the volume using alsa(might differ if you use pulseaudio)
amixer -c 0 set Master "$@" > /dev/null

# Query amixer for the current volume and whether or not the speaker is muted
volume="$(amixer -c 0 get Master | tail -1 | awk '{print $4}' | sed 's/[^0-9]*//g')"
mute="$(amixer -c 0 get Master | tail -1 | awk '{print $6}' | sed 's/[^a-z]*//g')"
if [[ $volume == 0 || "$mute" == "off" ]]; then
    # Show the sound muted notification
    dunstify -a "changeVolume" -u low -i audio-volume-muted -r "$msgId" "Volume muted"
else
    # Show the volume notification
    dunstify -a "changeVolume" -u low -i audio-volume-high -r "$msgId" \
    "Volume: ${volume}%" "$(getProgressStringS 10 "<b> </b>" " " $volume)"
fi
    #+end_src

    Helperscript.

    #+begin_src shell  :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.local/bin/getProgressStringS"
# getProgressString <TOTAL ITEMS> <FILLED LOOK> <NOT FILLED LOOK> <STATUS>
# For instance:
# $ getProgressString 10 "#" "-" 50
# #####-----
# Note: if you want to use | in your progress bar string you need to change the delimiter in the sed commands
# Source: https://github.com/Fabian-G/dotfiles/blob/master/scripts/bin/getProgressString

ITEMS="$1" # The total number of items(the width of the bar)
FILLED_ITEM="$2" # The look of a filled item
NOT_FILLED_ITEM="$3" # The look of a not filled item
STATUS="$4" # The current progress status in percent

# calculate how many items need to be filled and not filled
FILLED_ITEMS=$(echo "((${ITEMS} * ${STATUS})/100 + 0.5) / 1" | bc)
NOT_FILLED_ITEMS=$(echo "$ITEMS - $FILLED_ITEMS" | bc)

# Assemble the bar string
msg=$(printf "%${FILLED_ITEMS}s" | sed "s| |${FILLED_ITEM}|g")
msg=${msg}$(printf "%${NOT_FILLED_ITEMS}s" | sed "s| |${NOT_FILLED_ITEM}|g")
echo "$msg"
    #+end_src
*** toggleTouchpadS
    #+begin_src shell :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.local/bin/toggleTouchpadS"
msgId="991050"
device="$(xinput list | grep -P '(?<= )[\w\s:]*(?i)(touchpad|synaptics)(?-i).*?(?=\s*id)' -o | head -n1)"
# If it was activated disable it and if it wasn't disable it
if [[ "$(xinput list-props "$device" | grep -P ".*Device Enabled.*\K.(?=$)" -o)" == "1" ]];then
    xinput disable "$device"
    dunstify -a "changeVolume" -u low -i audio-volume-muted -r "$msgId" "Touchpad off"
else
    xinput enable "$device"
    dunstify -a "changeVolume" -u low -i audio-volume-muted -r "$msgId" "Touchpad on"
fi
    #+end_src
*** backlightS

    Orig: [[https://github.com/Fabian-G/dotfiles/blob/master/scripts/bin/changeBrightness][Fabian-G]]

    #+begin_src shell :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.local/bin/backlightS"
msgId="981141"
xbacklight -time 0 -steps 1 "$@"
exactBrightness=$(xbacklight -get)
brightness=$(echo "(${exactBrightness} + 0.5) / 1" | bc)
dunstify -a "changeBrightness" -u low -i display-brightness-symbolic.symbolic -r "$msgId" \
"Brightness: ${brightness}%" "$(getProgressStringS 10 " " " " $exactBrightness)"


    #+end_src
** Sysadmin scripts
*** menuEditConfigsS
    #+begin_src shell :shebang "#!/bin/sh" :tangle-mode (identity #o555) :tangle "~/.local/bin/menuEditConfigsS"
# Adapted from https://www.gitlab.com/dwt1/dotfiles/-/blob/master/.dmenu/dmenu-edit-configs.sh

die() {
    echo "Error: $@"
    exit 1
    }
[ -z "$1" ] && die "This must be called with arguments"

# Command line arguments
MENU_CMD=$1
EDITOR_CMD=$2

# Options to pass to the menu program (list of config file names)
options="alacritty
zshrc
zshenv
zprofile
aliases
picom
qutebrowser
xmonad.hs
Xresources
quit"

# Choose one of the files, using $MENU_CMD
choice=`echo "$options" | $MENU_CMD "Edit config file: "`

# Find the path to the chosen file
case "$choice" in
    alacritty)
        file="$HOME/.config/alacritty/base.yml"
    ;;
    zshrc)
        file="$ZDOTDIR/.zshrc"
    ;;
    zshenv)
        file="$ZDOTDIR/.zshenv"
    ;;
    aliases)
        file="$HOME/.config/shell/aliasrc"
    ;;
    picom)
        file="$HOME/.config/picom/picom.conf"
    ;;
    zprofile)
        file="$ZDOTDIR/.zprofile"
    ;;
    qutebrowser)
        file="$HOME/.config/qutebrowser/config.py"
    ;;
    qutebrowser)
        file="$HOME/.config/qutebrowser/config.py"
    ;;
    xmonad.hs)
        file="$HOME/Projects/WS/ws.org"
    ;;
    ,*)
        exit 1
    ;;
esac

# Edit the chosen file, with the user-specified program
$EDITOR_CMD "$file"

    #+end_src
** Screenshots

   # Recording
   # Take screenshot
   # Print: Record audio or video; Del: kill recording
   super + Print
   dmenurecord
   super + Delete
   dmenurecord kill

   #+begin_src shell :shebang "#!/bin/bash" :tangle-mode (identity #o555) :tangle "~/.local/bin/screenshotS"
APP="maim"
LOCATION="$HOME/Pictures/Screenshots"
FNAME="screenshot-$(date '+%Y-%m-%d-%H:%M:%S').png"
TARGET="$LOCATION/$FNAME"
SMALL="/tmp/$FNAME.tmp"
CHOICE="Fullscreen"

mkdir -p "$LOCATION"

shoot() {
    CHOICE=$(printf "Selected area\\nCurrent window\\nFull screen\\nSelected area (copy)\\nCurrent window (copy)\\nFll screen (copy)" | rofi -dmenu -l 6 -i -p "Screenshot which area?")

    case "$CHOICE" in

        "Selected area")
            maim -s "$TARGET" ;;
        "Current window")
            maim -i "$(xdotool getactivewindow)"  "$TARGET" ;;
        "Full screen")
            sleep 0.5 && maim  "$TARGET" #Don't want the menu
            ;;
        "Selected area (copy)")
            maim -s |tee "$TARGET" | xclip -selection clipboard -t image/png ;;
        "Current window (copy)")
            maim -i "$(xdotool getactivewindow)" |tee "$TARGET" | xclip -selection clipboard -t image/png ;;
        "Full screen (copy)")
            sleep 0.5 && maim |tee "$TARGET" | xclip -selection clipboard -t image/png ;;
    esac
}

notify() {
    convert "$TARGET" -resize 128x128  "$SMALL"
    notify-send "$CHOICE" "screen-\nshot" -i "$SMALL"
    rm "$SMALL"
}

usage() {
    cat <<-EOF
     $(basename $0) -h -n
     -h this message
     -n screenshot
      If you use the script with -n, you get a fullscreen screenshot,
     otherwise:
     - Selected area
     - Current window
     - Full screen
     - Selected area (copy)
     - Current window (copy)
     - Full screen (copy)
EOF
    exit
}

while getopts "hn" opt; do
    case $opt in
        n)
            $APP "$TARGET" && notify
            exit
            ;;
        ,*) usage ;;
    esac
done

shoot && notify
   #+end_src

* Xmobar

  Three kind of fonts used, regular, bold for the time, and font-awesome for icons.
  Colors the same as in =xmonad.hs=.

  #+begin_src haskell :tangle "~/.config/xmobar/xmobarrc2.hs"
  Config { position   = Top
           , font              = "xft:Source Code Pro:size=9:bold:antialias=true"
           , additionalFonts   = [ "xft:FontAwesome:pixelsize=16:antialias=true:hinting=true:style=Bold",
                                   "xft:Noto Sans:size=10:style=Bold"]
           , fgColor  = "#ffffff"
           , bgColor  = "#000000"
           , alpha    = 150  -- 0 transparent, 255 opaque
           , sepChar  = "%"
           , alignSep = "}{"
           , template = " %StdinReader% }{ %cpu%  %memory%  %coretemp% %wi%  %battery% %keyb% | %date% "
           , commands = [ Run StdinReader
                        --, Run Date "%_I:%M" "time" 300 -- every 30s
                        --, Run Date "%A %_d %B" "date" 18000 -- every 30min
                        -- CPU core temperature
                        , Run CoreTemp [ "--template" , "<core0>/<core1>°C"
                                       , "--Low"      , "70"
                                       , "--High"     , "80"
                                       , "--low"      , "#33BB33"
                                       , "--normal"   , "#AA8800"
                                       , "--high"     , "#FF0000"
                                       ] 50 -- every 5s
                       , Run Com "myKbS" [] "keyb" 20
                       , Run Cpu [ "--template", "<fc=#a9a1e1><fn=1></fn></fc> <total>%"
                                --, "--normal","#bbc2cf"
                                , "-L", "40"
                                , "-H", "60"
                                , "-l", "#586e75"
                                , "-h", "#dc322f" -- red
                                ] 50
                       , Run Memory ["-t","<fc=#51afef><fn=1></fn></fc> <usedratio>%"
                                    , "-H","80"
                                    , "-L","10"
                                    , "-l", "#586e75"
                                    , "-h", "#268bd2" -- blue, just to differentiate from cpu bar
                                    ] 50
                       , Run Wireless "" -- will match any wireless device
                         [ "-a", "l"
                         , "-x", "-"
                         --, "-t", "<fc=#6c71c4><fn=1>\xf1eb</fn> <essid> <quality>%</fc>"
                         , "-t", "<fc=#6c71c4><fn=1>\xf1eb</fn> <essid>"
                         , "-L", "50"
                         , "-H", "75"
                         -- , "-l", "#dc322f" -- red
                         , "-l", "#6c71c4" -- violet
                         , "-n", "#6c71c4" -- violet
                         , "-h", "#6c71c4" -- violet
                         ] 10
                       , Run Battery
                         [ "-t", "<fc=#b58900><acstatus></fc>"
                         , "-L", "20"
                         , "-H", "85"
                         , "-l", "#dc322f"
                         , "-n", "#b58900"
                         , "-h", "#b58900"
                         , "--" -- battery specific options
                         -- discharging status
                         , "-o"  , "<fn=1>\xf242</fn> <left>% (<timeleft>) <watts>"
                         -- AC "on" status
                         , "-O"  , "<fn=1>\xf1e6</fn> <left>%"
                         -- charged status
                         , "-i"  , "<fn=1>\xf1e6</fn> <left>%"
                         , "--off-icon-pattern", "<fn=1>\xf1e6</fn>"
                         , "--on-icon-pattern", "<fn=1>\xf1e6</fn>"
                         ] 10
                       , Run Date "<fc=#268bd2><fn=1>\xf073</fn> %a %_d %b %Y | d.%j w.%W</fc>   <fc=#2AA198><fn=1></fn><fn=2> %H:%M:%S</fn></fc>" "date" 10
                        ]
           }

   #+end_src

  #+begin_src haskell :tangle "~/.config/xmobar/xmobarrc.hs"
  Config { position   = Top
           , font              = "xft:Source Code Pro:size=9:bold:antialias=true"
           , additionalFonts   = [ "xft:FontAwesome:pixelsize=16:antialias=true:hinting=true:style=Bold",
                                   "xft:Noto Sans:size=10:style=Bold"]
           , fgColor  = "#ffffff"
           , bgColor  = "#000000"
           , alpha    = 150  -- 0 transparent, 255 opaque
           , sepChar  = "%"
           , alignSep = "}{"
           , template = " %StdinReader% }{ %cpu%  %memory%  %coretemp% %wi%  %battery% %keyb% | %date% "
           , commands = [ Run StdinReader
                        --, Run Date "%_I:%M" "time" 300 -- every 30s
                        --, Run Date "%A %_d %B" "date" 18000 -- every 30min
                        -- CPU core temperature
                        , Run CoreTemp [ "--template" , "<core0>/<core1>°C"
                                       , "--Low"      , "70"
                                       , "--High"     , "80"
                                       , "--low"      , "#33BB33"
                                       , "--normal"   , "#AA8800"
                                       , "--high"     , "#FF0000"
                                       ] 50 -- every 5s
                       , Run Com "myKbS" [] "keyb" 20
                       , Run Cpu [ "--template", "<fc=#a9a1e1><fn=1></fn></fc> <total>%"
                                --, "--normal","#bbc2cf"
                                , "-L", "40"
                                , "-H", "60"
                                , "-l", "#586e75"
                                , "-h", "#dc322f" -- red
                                ] 50
                       , Run Memory ["-t","<fc=#51afef><fn=1></fn></fc> <usedratio>%"
                                    , "-H","80"
                                    , "-L","10"
                                    , "-l", "#586e75"
                                    , "-h", "#268bd2" -- blue, just to differentiate from cpu bar
                                    ] 50
                       , Run Wireless "" -- will match any wireless device
                         [ "-a", "l"
                         , "-x", "-"
                         --, "-t", "<fc=#6c71c4><fn=1>\xf1eb</fn> <essid> <quality>%</fc>"
                         , "-t", "<fc=#6c71c4><fn=1>\xf1eb</fn> <essid></fc>"
                         , "-L", "50"
                         , "-H", "75"
                         -- , "-l", "#dc322f" -- red
                         , "-l", "#6c71c4" -- violet
                         , "-n", "#6c71c4" -- violet
                         , "-h", "#6c71c4" -- violet
                         ] 10
                       , Run Battery
                         [ "-t", "<fc=#b58900><acstatus></fc>"
                         , "-L", "20"
                         , "-H", "85"
                         , "-l", "#dc322f"
                         , "-n", "#b58900"
                         , "-h", "#b58900"
                         , "--" -- battery specific options
                         -- discharging status
                         , "-o"  , "<fn=1>\xf242</fn> <left>% (<timeleft>) <watts>"
                         -- AC "on" status
                         , "-O"  , "<fn=1>\xf1e6</fn> <left>%"
                         -- charged status
                         , "-i"  , "<fn=1>\xf1e6</fn> <left>%"
                         , "--off-icon-pattern", "<fn=1>\xf1e6</fn>"
                         , "--on-icon-pattern", "<fn=1>\xf1e6</fn>"
                         ] 10
                       , Run Date "<fc=#268bd2><fn=1>\xf073</fn> %a %_d %b %Y | d.%j w.%W</fc>   <fc=#2AA198><fn=1></fn><fn=2> %H:%M:%S</fn></fc>" "date" 10
                        ]
           }

   #+end_src


  #+begin_src haskell :tangle "~/.config/xmobar/xmobarDebug.hs"
  Config { position = Top
           , font     = "xft:Source Code Pro:size=9:bold:antialias=true"
           , additionalFonts   = [ "xft:FontAwesome:pixelsize=16:antialias=true:hinting=true",
                                   "xft:Noto Sans:size=10:style=Bold"]
           , fgColor = "#ffffff"
           , bgColor = "#000000"
           -- , alpha = 50  -- 0 transparent, 255 opaque
           , sepChar = "%"
           , alignSep = "}{"
           , template = " %UnsafeStdinReader% "
           , commands = [ Run UnsafeStdinReader --StdinReader
                        ]
           }

   #+end_src

* Thanks

  Monkey see, monkey do:

  - [[https://github.com/pjones/xmonadrc][pjones/xmonadrc@github]] - MyWorkspaces is based on his system, his is nicer , though
  - [[https://github.com/altercation/dotfiles-tilingwm][Ethan Schoonover]], a very nice setup on Github. See also on [[https://www.youtube.com/watch?v=70IxjLEmomg][Youtube]].
  - [[https://github.com/quarkQuark/dotfiles][QuarkQuark]], my setup started out as his'.
* COMMENT Document settings
  This makes the identation stay the same over multiple blocks.

# Local Variables:
# org-src-preserve-indentation: t
# eval: (add-hook 'after-save-hook (lambda () (org-babel-tangle)) nil t)
# End:
